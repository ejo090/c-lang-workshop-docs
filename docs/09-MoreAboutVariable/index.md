#  変数についてより詳しく

C言語勉強会 第九回

kumar8600  
June 2, 2013

----
###  今回の内容

* 型変換
    * 暗黙の型変換
    * 明示的型変換（キャスト）
* データ型
    * 符号の有無
    * 最大値・最小値
* スコープ
    * 変数が存在する範囲
* 記憶クラス指定子
    * 変数の保存方法を指定する
* 型修飾子
    * 変数の属性を指定する

----
##  型変換

----
###  暗黙の型変換


----
###  明示的型変換（キャスト）

----
##  データ型をもっと知ろう

----
###  符号の有無

以下のキーワードを整数型の前後に付加することで符号の有無を指定する。

<table>
    <tr>
        <th>
            キーワード
        </th>
        <th>
            意味
        </th>
    </tr>
    <tr>
        <td>
            signed
        </td>
        <td>
            符号あり
        </td>
    </tr>
    <tr>
        <td>
            unsigned
        </td>
        <td>
            符号なし
        </td>
    </tr>
</table>

符号無しのint型変数を宣言するには以下のように書く。

    unsigned int x;

符号がないので、当然負の数は扱えない。

これらのキーワードを省略した場合、自動的に`signed`が指定される。<small>ただしchar型は処理系による</small>

----

###  なぜわざわざ符号なしの変数なんか宣言するのか？

それは、符号なしの時のほうが、扱える値の範囲が正の方向に長いので、そのほうが便利な場面があるからだ。<small>これは実際にそういった場面が来ればわかると思う。</small>

----
###  整数型の最大値・最小値

変数の型によって、扱える値の範囲は変わる。

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      容量
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      char
    </td>
    <td rowspan="2">
      1
    </td>
    <td>
        -128 ～ 127
    </td>
  </tr>
  <tr>
    <td>
      unsinged
    </td>
    <td>
        0 ～ 255
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      short
    </td>
    <td rowspan="2">
      2
    </td>
    <td>
        -32,768 ～ 32,767
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        -32,768 ～ 32,767
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      int<small>※</small>
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
</table>
<small>※大半の32bit、64bit環境において。</small>

----

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      容量
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long long
    </td>
    <td rowspan="2">
      8
    </td>
    <td>
        -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807(±約922京)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～18,446,744,073,709,551,615(約1844京)
    </td>
  </tr>
</table>

<small>UNIX 64bit環境ではlong型はlong long型と同じ大きさになる。  
Cの規格では、char型以外の変数の大きさは定義されていない。  
`short`, `long`, `long long` は `~ int`の略である。</small>

----
###  浮動小数点型

精度が低い順に、`float`, `double`, `long double` がある。

とりあえずdouble型を使うと高速だし十分な精度があると思う。

----
## スコープ

----
###  ブロック

`{`と`}`に囲まれた領域をブロックと呼ぶ。

----
###  グローバル変数

全てのスコープからアクセスできる変数

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        
        printf("%d\n", a);
        
        return 0;
    }

上の例では a の値 3 が出力される。

a のようにどこの関数の中でもない、プログラムの最も外側の部分に書かれた変数がC言語のグローバル変数であり、すべてのブロック（関数）からアクセスできる。

----
###  ローカル変数

プログラムの一部分でしかアクセスできない変数のこと（グローバル変数の逆）

----

    #include <stdio.h>
    
    void print_a() {
        int o = a;
        printf("%d\n", o);
    }
    
    int main(void) {
        int a = 10;  /* ここから変数 a にアクセスできる */
        
        print_a();
        
        return 0;
    } /* ここで変数 a は開放され、消滅する */

上の例は、コンパイル時にエラーとなる。 
ローカル変数は、その変数が宣言された場所からその変数が定義されたブロックを抜けるまででしかアクセス出来ないからだ。

この例では a にアクセスできるのはAからBまでである。

こういったある変数や関数が特定の名前で参照される範囲のことを、 *スコープ* と呼ぶ。

----
###  変数の優先度

ブロックの外側で宣言された変数よりも、内側で宣言された変数が優先される。 

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        int a = 10;
        
        printf("%d\n", a);
        
        return 0;
    }

上の例では、main関数の中で宣言された方の a の値 10 が出力される。  


----
###  理解しているか？

今までの内容を理解しているなら、下のプログラムを実行するとどう出力されるかわかるはずだ。

    #include <stdio.h>
    
    int main(void) {
        int a = 10;
    
      if(1) {
        int a = 20;
        printf("%d\n", a);
      }
        
        printf("%d\n", a);
    
      return 0;
    }

----

main関数ではじめに a を宣言し、10で初期化した。その後、if文の中でもう一度 a という名前の変数を宣言したが、これらは全く別の変数であることを意識出来れば、なんの迷いもない問題だ。答えは`20(改行)10`。

----
##  記憶クラス指定子

----
###  記憶クラス指定子

変数の保存方法を更に細かく指定する

    static int a;

この`static`のように、通常の変数の宣言の前につける。

以下の五つが存在する

* static
* extern
* 時代遅れな指定子
    * auto
    * register
* typedef
    * 構文の都合で分類されているだけ
----
###  auto | 自動変数

プログラム中の宣言されたブロック内でのみ使用できる変数。  
つまり、 *今まで使ってきた普通の変数* 。

    auto int a;

または

    int a;

のように書く。auto句を付けたところで全く意味は無い。と言うか混乱を招くので付けないほうがいい。

そんな句がなぜあるか？というと、C言語の前身であるB言語は変数の宣言に`auto 変数名`と書いたからである。型名が無いが、B言語には整数型しかなかった。

----
###  自動変数のココが自動

*特定の区域内に到達すると自動的に変数領域を確保し* 、 *その区域を脱すると自動的にその領域を開放して消滅する* 点が自動

    void print_a() {
        int o;
        o = 10;
        printf("%d\n", o);
    }

この関数を呼び出した場合、  
関数を呼び出すと同時にメモリーのどこかあいてるところに int型変数o のための領域を確保し、  
関数を実行しおわると先ほど確保した 変数o の領域を開放し消滅する。

----

砕いていうと、関数を呼び出すたび変数を作り、抜けるとき変数を消してるだけである。

この仕組みがスコープを生み出している。

----
###  static | 静的変数

どこに宣言していようとも関係なく、*プログラムの実行開始時にメモリ上に作られ、初期値も与えられる変数* 。

*関数が終了しても値を保持しているローカル変数* 。という認識で問題ないだろう。

----

    #include <stdio.h>
    
    void printCalledNum() {
        static int n = 0;
        n++;
        printf("%d回目の呼び出し\n", n);
    }
    
    int main(void) {
        
        printCalledNum();
        printCalledNum();
        printCalledNum();
        
        return 0;
    }

printCalledNum関数の n は静的変数なので、printCalledNum関数を抜けだしても値は保持されている。

----
###  静的変数は必ず初期化される

静的変数は、具体的な初期値を与えなくても、必ず 0 で初期化されることが保証されている。

なので、前のページの例ではわかりやすいように 0 で n を初期化しているが、書かなくても同じ結果である。

もしかして知らなかった人もいるかもしれないが、逆に普通の変数や配列は、宣言しても初期値は入っていないので注意。<small>厳密にはメモリ上に残ったゴミが初期値。</small>

----
###  extern

C言語でも複数ファイルを使ったプログラムをかけるのだが、その際に別のファイルに書かれたグローバル変数や関数を使うためにextern宣言が必要になる。

この話は面白いのだが奥が深いので、今回は省略する。知りたかったらググるといい。

----
###  register | レジスター変数（時代遅れらしい）

コンピューターには主記憶装置である「メモリ」の他に、CPUに内蔵されていて、メモリと比べるととてつもなく速く、低容量な「 *レジスタ* 」がある。実はCPUによる計算は、メモリに入っている値を一度レジスタにコピーしてから行われている。（なんか最近は違うらしい）

そんな高速なレジスタに変数を格納したいとき、この指定子を使う。

	register int a;

register変数は「出来れば」レジスタに変数を格納する。容量が足りないとき等は結局いつもどおりメモリを使うので注意。

あと、register変数のアドレスを得ることは出来ない。

----

ちなみに、 *今はコンパイラーの最適化が凄いので、こんなもの書く必要はない* （凄いプログラマーならあるいは）。私も書いたことないです。

----
###  typedef

*データ型に新しい名前（別名）をつける。*

<small>構造体を宣言する際にも何気なく使ってきたと思う。</small>

例えば、int に自分の好きな別名をつけるには、

	typedef int Seisu;

このように書く。この例では int に Seisu という別名をつけた。なので以降、

	Seisu n;

と書くことでも int 型変数 n を宣言できる。

----
###  typedef | よくある使用例

unsigned int に uint という別名をつける

	typedef unsigned int uint;

ある構造体を名前をつけ宣言する。

	typedef struct {
		char name[20];
		double height;
		double weight;
	} HUMAN;

name、height、weightをもつ構造体に HUMAN という名前をつけた。

----
##  型修飾子


----
###  型修飾子

データ型を用途に応じてきめ細かく指定する。

変数を宣言する際、型の前後に付加する。

    const int a;

または

    int const a;

のように記述する。

型修飾子が付いている型と付いてない型は別の型扱いされる。

<small>例:）int と const int は別の型</small>

----

以下の二つについて紹介する。

* const
* volatile

----
###  定数（const）

指定した変数が定数であることを指定する。

    #include <stdio.h>
        
    int main(void) {
        
        const int a = 10;
        a += 2;
        
        printf("%d\n", a);

        return 0;
    }

このプログラムはコンパイル時にエラーする。  
定数として宣言した `a` を `a += 2`で、値を書き換えようとしたことが原因である。

----

また、定数の初期化は宣言時にしか行えないので注意。

ポインタ定数の場合特別な挙動をする。これを積極的に使うと便利である。ポインタを紹介してないから今は書かない。

----
###  volatile変数

コンパイラによる最適化を行わない変数。

今のコンパイラは頭がいいので、私たちの書いたクソのようなプログラムをできるだけ素晴らしい効率で動くように最適化する。

だが、マルチスレッドなプログラム等、コンパイラの設計者の想定を超えるプログラムを書いた場合、逆にその最適化のせいでプログラムが正常に作動しなくなることがある。

その際に、この変数にはお節介するなよ？とコンパイラに伝えるための修飾子である。

----

↓次回↓

* アドレス
    * 変数のメモリ上での座標
* ポインタ変数
    * アドレスを代入するための変数の型