#  ポインタと動的メモリ確保
C言語勉強会 第十一回

kumar  
September 24, 2013  
[引用 : Programming Place Plus](http://www.geocities.jp/ky_webid/index.html)

----
### 今回の内容

* 構造体へのポインタ
	* アロー演算子
* constポインタ
	* 間接参照先への代入を禁止
* 動的メモリ確保
	* 可変長な配列を実現できる

----
## 構造体へのポインタ

----
### 構造体へのポインタ

参照先のメンバにアクセスするには、`.`ではなく、アロー演算子`->`を使う。

#### 文法
	構造体へのポインタ->メンバ名

----

#### 例

	typedef struct {
		char name[20];
		float height;
		float weight;
	} Human;

	/* Human構造体のポインタを引数に取る関数 */
	void printHuman(Human *p) {
		printf(" 名前: %s", p->name);
		printf(" 身長: %f", p->height);
		printf(" 体重: %f¥n", p->weight);
	}

----
## constポインタ

----
### おさらい｜const変数

> 指定した変数が定数であることを指定する。  
> 定数とは、初期化出来ても書き換え出来ない変数のことである。
>
> #### 文法
> 	const 型名 変数名;
>	または
>	型名 const 変数名;


**これに対して、constポインタはポインタ自身でなく、参照先の書き換えを禁じる。**

----
### constポインタ

そのポインタから参照先を書き換えることを禁じる

#### 文法
	const 型 *変数名
	または
	型 const *変数名

----
#### 例
int 型変数 x が宣言されているとする。

	const int *cp = &x;	/* constポインタを宣言 */
	int *p = &x;
	
	int foo = 10 + *cp;	/* 可能 */
	*p = 100; 			/* 可能 */
	
	*cp = 5;			/* 不可能。コンパイルエラー */
	
* constポインタ cp からの__書き換えのみが不可能__

----
### constポインタでできること
	
ミスが減る。特に配列を<small>（ポインタにして）</small>引数にとる関数を書く際に、配列を誤って書き換えることがない

#### 例
constポインタを引数にとる関数の例

	int strlen(const char *str) {
		int len = 0;
		while(str++ != '¥0')
			len++;
		return len;
	}
	
----

* この関数は引数にとった文字列の長さを返す関数である。よって、引数 str を書き換えることはない。この関数を書いた人は、誤って引数 str を書き換えてしまうプログラムを書いてしまうミスを防ぐため、char *strにconstをつけた。
	

----
## コラム

----
### i++ と ++i
インクリメントやデクリメントは、演算子を変数名の前に書くか後ろに書くかで名前、性質が変わる。

#### 文法
vを何らかの変数とする。

<table>
	<tr>
		<td>++v</td><td>前置インクリメント</td>
	</tr>
	<tr>
		<td>v++</td><td>後置インクリメント</td>
	</tr>
</table>

----
御存知の通り、インクリメントは「変数に１足す」という意味で、デクリメントは「変数から１引く」という意味である。だが、演算子が前置か後置かで、式の中で演算が行われるタイミングが異なる。

#### 前置インクリメント・デクリメント
式の評価より先に（イン｜デ）クリメントを行う。

#### 後置インクリメント・デクリメント
式の評価の後で（イン｜デ）クリメントを行う。

----
#### 例
	int n, i = 0;
	
	n = i++;	// n = 0, i = 1
	
	i = 0;
	
	n = ++i;	// n = 1, i = 1

----
### ポインタの複数宣言
ポインタを一行で一度に宣言するとき、

	int *x, y, z;
	
と書きたくなるかと思うが、こう書くと、xだけがポインタになり、yとzは通常の変数になってしまう。正しくは

	int *x, *y, *z;
	
こう書くのが正しい。

----
### アロー演算子は糖衣構文

アロー演算子も配列の添字と同じく、糖衣構文（シンタックスシュガー）である。

#### 文法

	ps->x

におけるアロー演算子は

	(*ps).x

の糖衣構文（シンタックスシュガー）である

----
### ポインタとconst修飾子
以下の例はconstポインタの宣言の文法である

	const int *x;
	int const *x;
	
だが以下の例はそうではない。

	int *const x: 

* こう書くと、xの参照先ではなく、xそのものを書き換えできなくなる。

----
## 動的メモリ確保

----
### 動的メモリ確保
実行時にメモリ領域の確保を行うこと。

今までの静的メモリとは違い、実行時に自由な大きさの配列を作ることができる。

なお、以降の関数を利用するためには、標準ライブラリ<stdlib.h>がインクルードされている必要がある。

----
### malloc()

	void *malloc(size_t size);

size バイト分のメモリを確保し、その領域へのポインタを返す。

エラー時にはNULLを返す。

----
### free()

	void free(void *pointer)

pointerの指すメモリブロックを開放する。

malloc等で動的確保したメモリは、この関数を使わない限り、プログラムが終了するまで開放されない。メモリリークやメモリの無駄遣いを防ぐため、**必ず使い終わったメモリはこの関数で開放すること**。

----
#### 例
長さ ? のint型配列を作る。

	size_t n = ?;
	int *p = malloc( n * sizeof(int) );

	/* 使い終わったら */
	free( p );

当然 ? は定数でも構わないが、定数なら通常の配列宣言でいいと思う。

----
### calloc()

	void *calloc(size_t nelements, size_t bytes)

bytesのサイズのメモリ領域をnelements個格納できるメモリ領域を確保する。

これは以下の様な解釈で問題ない。

	void *calloc(size_t nelements, size_t bytes) {
		return malloc(nelements * bytes);
	}

----
### realloc()

	void *realloc(void *pointer, size_t bytes)

pointerが指すメモリブロックをリサイズする。

具体的には、bytesバイトのメモリ領域を新たに確保して、pointerメモリブロックにあったデータはできる限りコピーする。

----
## 次回

----
### 次回予告（多分最終回）

* ファイル入出力
* 標準ライブラリ
 